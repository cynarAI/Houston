---
name: Testing Rules
description: Vitest Unit Tests und Playwright E2E Guidelines
ruleType: Auto
globs:
  - "**/*.test.ts"
  - "e2e/**"
  - "vitest.config.ts"
  - "playwright.config.ts"
---

# Testing Guidelines

Houston verwendet Vitest für Unit/Integration-Tests und Playwright für E2E-Tests.

## Test-Befehle

```bash
pnpm test        # Unit Tests einmalig
pnpm test:watch  # Unit Tests im Watch-Modus
pnpm e2e         # E2E Tests
pnpm e2e:ui      # E2E Tests mit UI
```

## Unit Tests (Vitest)

### Datei-Konvention
Test-Dateien liegen neben dem Source-Code:
```
server/
├── creditService.ts
├── creditService.test.ts    # ← Tests direkt daneben
├── referralService.ts
└── referralService.test.ts
```

### Test-Struktur
```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";

describe("CreditService", () => {
  let testUserId: number;

  beforeEach(async () => {
    // Setup: Test-User erstellen
    const db = await getDb();
    const [result] = await db.insert(users).values({
      openId: `test-${Date.now()}`,
      name: "Test User",
      credits: 50,
    });
    testUserId = result.insertId;
  });

  describe("getBalance", () => {
    it("should return current credit balance", async () => {
      const balance = await CreditService.getBalance(testUserId);
      expect(balance).toBe(50);
    });

    it("should throw error for non-existent user", async () => {
      await expect(CreditService.getBalance(99999)).rejects.toThrow();
    });
  });
});
```

### Was testen?

#### Priorität 1: Credit System
Das Credit-System ist geschäftskritisch und muss umfassend getestet werden:
- `CreditService.charge()` - erfolgreiche Abbuchung, insufficient credits
- `CreditService.grant()` - erfolgreiche Gutschrift
- `CreditService.getBalance()` - korrekte Balance
- Concurrent Charges - Race Conditions verhindern

```typescript
// Beispiel: Concurrent Charge Test
it("should prevent race conditions with atomic operations", async () => {
  // 50 Credits, 2x 30 Credits parallel → nur 1 sollte durchgehen
  const [result1, result2] = await Promise.all([
    CreditService.charge(userId, "TEST_1", 30),
    CreditService.charge(userId, "TEST_2", 30),
  ]);

  const successCount = [result1, result2].filter(r => r.success).length;
  expect(successCount).toBe(1);
  
  const finalBalance = await CreditService.getBalance(userId);
  expect(finalBalance).toBe(20); // 50 - 30
});
```

#### Priorität 2: Services
- `referralService.ts` - Referral-Code Generierung, Bonus-Vergabe
- `notificationService.ts` - Notification-Erstellung

#### Priorität 3: Router Logic
Komplexe Business-Logik in Routern:
- Goals: SMART Goal Validierung
- Todos: Status-Übergänge
- Chat: Session-Erstellung, Message-Handling

### Mocking

#### Database Mocking
Für isolierte Tests:
```typescript
import { vi } from "vitest";

vi.mock("./db", () => ({
  getDb: vi.fn().mockResolvedValue(mockDb),
}));
```

#### Externe Services mocken
```typescript
// LLM Service mocken
vi.mock("../_core/llm", () => ({
  callLLM: vi.fn().mockResolvedValue({
    content: "Mocked response",
  }),
}));
```

### Assertions

```typescript
// Equality
expect(value).toBe(5);
expect(obj).toEqual({ a: 1 });

// Truthiness
expect(value).toBeTruthy();
expect(value).toBeDefined();

// Exceptions
await expect(fn()).rejects.toThrow("error message");
await expect(fn()).rejects.toThrow(SomeError);

// Arrays
expect(array).toContain(item);
expect(array).toHaveLength(3);

// Objects
expect(obj).toHaveProperty("key", "value");
```

## E2E Tests (Playwright)

### Datei-Konvention
```
e2e/
└── app.spec.ts    # E2E Test Specs
```

### Test-Struktur
```typescript
import { test, expect } from "@playwright/test";

test.describe("Dashboard", () => {
  test.beforeEach(async ({ page }) => {
    // Login oder Setup
    await page.goto("/app/dashboard");
  });

  test("should display user credits", async ({ page }) => {
    await expect(page.getByTestId("credit-indicator")).toBeVisible();
  });
});
```

### Selektoren

#### Bevorzugt: data-testid
```tsx
// In Komponente
<button data-testid="create-goal-btn">Ziel erstellen</button>

// Im Test
await page.getByTestId("create-goal-btn").click();
```

#### Alternativ: Role + Text
```typescript
await page.getByRole("button", { name: "Ziel erstellen" }).click();
await page.getByText("Dashboard").click();
```

### Warten auf Elemente
```typescript
// Warten bis sichtbar
await expect(page.getByText("Erfolgreich")).toBeVisible();

// Warten auf Navigation
await page.waitForURL("/app/dashboard");

// Warten auf Netzwerk-Request
await page.waitForResponse(resp => 
  resp.url().includes("/api/trpc/goals.list")
);
```

### Page Object Pattern (optional)
Für komplexe Flows:
```typescript
class DashboardPage {
  constructor(private page: Page) {}
  
  async createGoal(title: string) {
    await this.page.getByTestId("new-goal-btn").click();
    await this.page.getByLabel("Titel").fill(title);
    await this.page.getByRole("button", { name: "Speichern" }).click();
  }
}
```

## Best Practices

### Do
- Tests beschreiben Verhalten, nicht Implementierung
- Ein Assertion-Fokus pro Test
- Klare, beschreibende Testnamen
- Setup/Teardown für Isolation
- Testen von Edge Cases (leere Arrays, null, max values)

### Don't
- Keine Implementierungsdetails testen
- Kein Over-Mocking - echte DB für Integration Tests
- Keine flaky Tests (Race Conditions, Timing)
- Keine Tests ohne Assertions

### Beispiel: Guter vs. schlechter Testname
```typescript
// SCHLECHT
it("works", async () => { ... });
it("test charge", async () => { ... });

// GUT
it("should deduct credits when user has sufficient balance", async () => { ... });
it("should return insufficient_credits error when balance too low", async () => { ... });
```

## CI Integration

Tests laufen automatisch bei:
- Pull Requests (alle Tests)
- Push auf main (alle Tests)

```yaml
# .github/workflows/test.yml
- run: pnpm test
- run: pnpm e2e
```

## Coverage

Aktuell kein Coverage-Tracking aktiv. Bei Bedarf:
```bash
pnpm test --coverage
```

Mindestanforderungen für neue Features:
- Kritische Business-Logik: >80% Coverage
- Services: >70% Coverage
- UI Components: Nur bei komplexer Logik
